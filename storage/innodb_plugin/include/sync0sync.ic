/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.
Copyright (c) 2008, Google Inc.

Portions of this file contain modifications contributed and copyrighted by
Google, Inc. Those modifications are gratefully acknowledged and are described
briefly in the InnoDB documentation. The contributions by Google are
incorporated with their permission, and subject to the conditions contained in
the file COPYING.Google.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/sync0sync.ic
Mutex, the basic synchronization primitive

Created 9/5/1995 Heikki Tuuri
*******************************************************/

/******************************************************************//**
Sets the waiters field in a mutex. */
UNIV_INTERN
void
mutex_set_waiters(
/*==============*/
	mutex_t*	mutex,	/*!< in: mutex */
	ulint		n);	/*!< in: value to set */
/******************************************************************//**
Reserves a mutex for the current thread. If the mutex is reserved, the
function spins a preset time (controlled by SYNC_SPIN_ROUNDS) waiting
for the mutex before suspending the thread. */
UNIV_INTERN
void
mutex_spin_wait(
/*============*/
	mutex_t*	mutex,		/*!< in: pointer to mutex */
	const char*	file_name,	/*!< in: file name where mutex
					requested */
	ulint		line);		/*!< in: line where requested */
#ifdef UNIV_SYNC_DEBUG
/******************************************************************//**
Sets the debug information for a reserved mutex. */
UNIV_INTERN
void
mutex_set_debug_info(
/*=================*/
	mutex_t*	mutex,		/*!< in: mutex */
	const char*	file_name,	/*!< in: file where requested */
	ulint		line);		/*!< in: line where requested */
#endif /* UNIV_SYNC_DEBUG */
/******************************************************************//**
Gets the waiters field in a mutex.
@return	value to set */
UNIV_INLINE
ulint
mutex_get_waiters(
/*==============*/
	const mutex_t*	mutex)	/*!< in: mutex */
{
	const volatile ulint*	ptr;	/*!< declared volatile to ensure that
					the value is read from memory */
	ut_ad(mutex);

	ptr = &(mutex->waiters);

	return(*ptr);		/* Here we assume that the read of a single
				word from memory is atomic */
}

/******************************************************************//**
Unlocks a mutex owned by the current thread. */
UNIV_INLINE
void
mutex_exit(
/*=======*/
	mutex_t*	mutex)	/*!< in: pointer to mutex */
{
	ut_ad(mutex_own(mutex));

	ut_d(mutex->thread_id = (os_thread_id_t) ULINT_UNDEFINED);

#ifdef UNIV_SYNC_DEBUG
	sync_thread_reset_level(mutex);
#endif

	os_fast_mutex_unlock(&mutex->os_fast_mutex);

#ifdef UNIV_SYNC_PERF_STAT
	mutex_exit_count++;
#endif
}

/******************************************************************//**
Locks a mutex for the current thread. If the mutex is reserved, the function
spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the mutex
before suspending the thread. */
UNIV_INLINE
void
mutex_enter_func(
/*=============*/
	mutex_t*	mutex,		/*!< in: pointer to mutex */
	const char*	file_name,	/*!< in: file name where locked */
	ulint		line)		/*!< in: line where locked */
{
	extern ulint	srv_fatal_semaphore_wait_threshold;
	ulint		fatal_timeout = srv_fatal_semaphore_wait_threshold;
	ut_ad(mutex_validate(mutex));
	ut_ad(!mutex_own(mutex));

#ifdef UNIV_SYNC_DEBUG
	mutex_set_debug_info(mutex, file_name, line);
#endif
	mutex_add_to_thread_waiting_list(mutex);
	ut_d(mutex->count_using++);

	time_t mutex_enter_time = time(NULL);
	while (1) {
		struct timespec maxtime;
		maxtime.tv_sec	= time(NULL) + 60;
		maxtime.tv_nsec = 0;

		int res = os_fast_mutex_timedlock(&mutex->os_fast_mutex, &maxtime);
		if (res == ETIMEDOUT) {
			fprintf(stderr,
				"ERROR: Mutex at %p owned for more than 60 seconds; "
				"possible deadlock.  I'll keep waiting but don't "
				"count on it.\n", mutex);

			if ((ulint)(time(NULL) - mutex_enter_time) > fatal_timeout) {
			  fprintf(stderr,
				  "InnoDB: Error: mutex wait has lasted"
				  " > %lu seconds\n"
				  "InnoDB: We intentionally crash the server,"
				  " because it appears to be hung.\n",
				  (ulong) srv_fatal_semaphore_wait_threshold);

			  ut_error;
			}
		} else {
		  ut_a(res == 0);
		  mutex->thread_id = os_thread_get_curr_id();
		  mutex_remove_from_thread_waiting_list();
		  return;
		}
	}
}
